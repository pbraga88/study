2.4 Boolean Algebra and Computer Logic
======================================
Conjunction		-> Duas condições devem ser atendidas
|if (a==1 && b==1)
|	cout << "True" << emdl;
O operador da 'Conjunction' é &&. Trata-se de um operador binário, com menor 
prioridade do que os operadores de comparação, portanto a seguinte linha
pode ser expressada sem a necessidade do uso de parênteses:
|counter>0 && value==100

Disjunction		-> Apenas uma condição precisa ser atendida
|if (a==1 || b==1)
|	cout <<"True" << endl;
O operador da 'Disjunction' é ||. Trata-se também de um operador binário com 
menor prioridade do que && (bem como '+' em relação à '*')

logical negation	-> Este operador unário é representado por '!'. Ele torna 
'true' em 'false' e 'false' em 'true'. Sua prioridade é muito alta, assim como 
os operadores de incremento e decremento

**************************************************************
A lei de Morgan:											 *
A negação de uma conjunção é igual a disjunção das negações:  *
!(a && b) = !a || !b;										 *
															 *
A negação de uma disjunção é igual conjunção das negações:	 *
!(a || b) = !a && !b;										 *
**************************************************************

bitwise operators	-> São os operadores (4) que permitem manipular bit únicos:
- & bitwise conjunction
- | bitwise disjunction
- ~ bitwise negation
- ^ bitwise exclusive or

Importante: Os argumentos dessas operações devem ser inteiros (int, long, short ou char); não se deve usar 
ponto flutuante (float)

Operações lógicas e binárias
Dado:
	i = 00000000 00000000 00000000 00001111
	j = 00000000 00000000 00000000 00010110
	int logic = i && j; // = 00000000 00000000 00000000 00000001
À operação de conjunção acima, apenas interessa saber se os números são inteiros positivios ou não. O resultado será 
sempre booleano true (1) ou booleano false (0) dependendo das variáveis. 
Já a operação de bit (bitwise), vai bit a bit, portanto a linha de código abaixo resulta em um valor diferente:
	int bit = i & j;// = 00000000 00000000 00000000 00000110
Utilizando os operadores de negação !(lógico) e ~(bitwise), temos:
	int logicneg = !i;// = 00000000 00000000 00000000 00000000
	int bitneg = ~i;// = 11111111 11111111 11111111 11110000
Õ valor decimal de i será -16, após a operação bitiwise acima, pois trata-se de um complemento de dois

Formas abreviadas:
x=x|y <=> x|=y
x=x&y <=> x&=y
x=x^y <=> x^=y